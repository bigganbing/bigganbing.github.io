---
layout:     post
title:      计算机编码学习笔记
subtitle:   补坑，知识整理。
date:       2018-10-19
author:     viewsetting
header-img: img/post-adjani.jpg
catalog: true
tags:
    - 补码
    - 反码
    - 原码
    - 二进制
    - lowbit
---

# 序言

计算机使用二进制而非十进制表示数值或可以称其为信息。但是二进制只是由01比特序列构成的，这样自然就引出了一个问题：如何规范二进制的编码表示呢？在计算机科学中，有原码，反码与补码三个基本概念（移码单独列出）。

这篇笔记是基于《计算机组成原理》（唐朔飞，第二版）的第六章学习经历的启发，加上先前的一些认识所整合的一篇 **助记性笔记**（没错我现在记性挺差），当然也可以作为初学者的参考文。但由于本人才学疏浅，如有疏漏错误请谅解。



## 原码



### 从循环取模求除数说起

二进制是由0和1组成的，这一点可以从我们十进制的组成里看出。如果把十进制看作由单个数字作为元素生成的字符串的话，数字集合$S=\{0,1,2,3,4,5,6,7,8,9\}$ 。可以注意到这里的$S$ 还可以写作$\{i|i \in k$ $ mod$ $ 10 ,\forall k \in N \}$ 。所以类似的，二进制的元素集合$Bin$=$\{i|i \in k$ $ mod$ $ 2 ,\forall k \in N \}$ =$\{0,1\}$。

#### 接下来实现一个十进制数到二进制的转换：

给定一个十进制整数（注意：这里为unsigned integer)，如11。算法就是将这个数字不断的除2并保留余数，将保留的余数按顺序插入到一个队列中，如最先求出的余数放到队列最右端，接下的余数都依次插入到队列左端直到这个数字变为0结束，最后生成的队列从左往右读其实就是这个十进制整数的二进制原码。

11的变化：$11 \rightarrow 5 \rightarrow 2 \rightarrow  1 \rightarrow 0$ 

余数队列(-为空): ---- $ \rightarrow$ ---1 $ \rightarrow$  --11  $ \rightarrow$  -011 $ \rightarrow$ 1011

于是从左至右就是1101，即十进制的11。

### 数学解释：

> 对于一个$n$进制的$k$位的数$Num$，可以表示为：$Num=\sum_{i=1}^k num_i*n^{i-1}$，其中$num_i$是第$i$位的值，在1到$k-1$之间

所以刚刚的$1101=1 \cdot 2^3 + 0 \cdot 2^2 + 1  \cdot 2^1 + 1 \cdot 2^0 = 8+2+1 = 11$



### 如果这个时候出现了负数该如何表示？

引入符号位，1表示负数，0表示正数。

| 十进制绝对值（取2位数值位） | 正数原码 | 负数原码 |
| :-------------------------: | :------: | :------: |
|              0              |   000    |   100    |
|              1              |   001    |   101    |
|              2              |   010    |   110    |
|              3              |   011    |   111    |



## 反码(1's  Complement)

### 定义

> **正数的反码与其原码相同；负数的反码是对其原码逐位取反，不包含符号位。**

因此，在原码的基础上，反码可以很容易求出。

| Binary | 反码对应的十进制 | 原码(带符号位表示) |
| :----: | :--------------: | :----------------: |
|  000   |        0         |         0          |
|  001   |        1         |         1          |
|  010   |        2         |         2          |
|  011   |        3         |         3          |
|  100   |        -3        |         -0         |
|  101   |        -2        |         -1         |
|  110   |        -1        |         -2         |
|  111   |        -0        |         -3         |



## 补码

### 如何生成补码

首先，如果给了一个数的有符号整数原码表示，那么其补码就是对于负数保持符号位不变，然后将数值部分取反再加1，非负数不变。 



| Binary | 反码对应的十进制 | 原码(带符号位表示) | 补码表示 |
| :----: | :--------------: | :----------------: | :------: |
|  000   |        0         |         0          |    0     |
|  001   |        1         |         1          |    1     |
|  010   |        2         |         2          |    2     |
|  011   |        3         |         3          |    3     |
|  100   |        -3        |         -0         |    -4    |
|  101   |        -2        |         -1         |    -3    |
|  110   |        -1        |         -2         |    -2    |
|  111   |        -0        |         -3         |    -1    |

### 补码机制的类比

假如给你一个钟表，只有1到12的整数表示，现在是10点钟，如何得出5小时后的时间呢，很简单：10+5=15，15 mod 12 =3,所以是三点钟（上午还是下午，那无所谓）。那么如何算出十一个小时前的时间呢？由于10-11=-1，所以有些麻烦。我们换个角度考虑：10-11=10+（-11），由于时钟在前一个10+5的例子中已经显示出了同余性，我们便在这里凑一个同余，即$10+(-11) \equiv 10 +(-11) +12 \space mod \space  (12)$，那么在时钟的例子中，-11的编码就可以写成1。在是一个例子，3-11在时钟里就是3+1=4点整，结论依旧成立！

回到二进制补码：